- Template có sẵn : https://adminlte.io/themes/v3/pages/UI/general.html#
- Cài Laragon ( cài tất cả các phiên bản laravel xem có bị lỗi gì không)
    + https://laragon.org/docs/install.html
    + README.md 
        MySQL login*: 
        user: root
        password:
        *The default username is 'root' and empty password
        ----------------------------------------------------
        Document Root:
        C:\laragon\www
        ----------------------------------------------------
        Hotkey to open Terminal globally: 
        CTRL+ALT+T
        For more information, please visit: http://laragon.org
        Thank you for using Laragon.
        leokhoa@gmail.com

    + Hoàn toàn giống Xampp chỉ là nó có thể thay đổi phiên bản thôi 
        + Trang chủ : http://localhost/
        + Mysql database cũng tương tự 
        + 


-----------------------------Service-----------------------
Service 
    Bạn đang nói đến Service trong thư mục app/Services. Thư mục app/Services thường được sử dụng để chứa các class dịch vụ tùy chỉnh của bạn, đây là một phần của cơ chế Dependency Injection trong Laravel.
    Mục đích chính của việc sử dụng các class dịch vụ trong thư mục app/Services là để tách logic xử lý khỏi controllers và các phần khác trong ứng dụng. Điều này giúp mã của bạn trở nên dễ đọc hơn, dễ bảo trì hơn và dễ dàng kiểm thử.
    Ví dụ, nếu bạn có một chức năng cần thực hiện một số xử lý phức tạp như gửi email, xử lý dữ liệu, gọi API bên ngoài, bạn có thể tạo một class dịch vụ trong thư mục app/Services để thực hiện các tác vụ này. Sau đó, bạn có thể tiêm nó vào controller hoặc bất kỳ nơi nào cần sử dụng thông qua Dependency Injection.
    Ví dụ về cách sử dụng một class dịch vụ trong controller:

    use App\Services\MyService;

    class MyController extends Controller
    {
        protected $myService;

        public function __construct(MyService $myService)
        {
            $this->myService = $myService;
        }

        public function index()
        {
            $data = $this->myService->getData();
            // ...
        }
    }
    Trong ví dụ trên, $myService là một instance của MyService class, và bạn có thể gọi các phương thức của class này để thực hiện các tác vụ cụ thể.
    Điều này giúp bạn giữ cho logic của bạn được tách ra một cách rõ ràng và sẽ làm cho controllers của bạn trở nên nhẹ nhàng và dễ kiểm thử hơn.

+ Mục đích của Service là 
    + Tách phần code logic từ Controller ra để cho controller nhẹ nhàng hơn . 
    + Nếu nhiều chỗ dùng lui dùng tới phần code đó => tách ra để ở service => controller nào cần thì bỏ vào . 

+ Không có câu lệnh tạo file Service (tự tạo bằng tay)

p12 
Ví dụ về Service : 
Service 
    + C:\Users\ADMIN\Downloads\izisoft\p12nhadatexpress\app\Services\UserService.php

Controllers 
    + p12nhadatexpress\app\Http\Controllers\Admin\Report\Account\ReportCommentAccountController.php
    + p12nhadatexpress\app\Http\Controllers\Admin\Comment\CommentController.php
    + p12nhadatexpress\app\Http\Controllers\Admin\Comment\ReportCommentController.php
    + p12nhadatexpress\app\Http\Controllers\Admin\Event\EventReportController.php
    + p12nhadatexpress\app\Http\Controllers\Admin\PersonalPage\PersonalPageReportController.php
    + ...

=> Ví dụ hàm : $this->userService->blockUser => được dùng lại rất nhiều lần => tách ra khỏi Controller để
cho vào Service , lúc này , làm nào cũng dùng được . 


-----------------------------------------------Quản lý, tạo dữ liệu mẫu DB với migrate, seeder, factory---------------------------------------------------------------------
+ Seeder và Factory 
    + Tạo Seeder:
        > php artisan make:seeder UsersTableSeeder
    
    + Có hai trường hợp : 
        + Tạo một dòng dữ liệu 
            + <?php

            namespace Database\Seeders;
            
            use Illuminate\Database\Seeder;
            use Illuminate\Support\Facades\DB;
            use Illuminate\Support\Facades\Hash;
            use Faker\Factory as Faker;
            
            class UsersTableSeeder extends Seeder
            {
                public function run()
                {
                    DB::table('users')->insert([
                        'name' => 'John Doe23',
                        'email' => 'johndoe23@example.com',
                        'password' => Hash::make('password223'),
                        'google_id' => '11743319275979465222223',
                        'github_id' => '8156345123',
                        'username' => 'johnprovip23',
                        'avatar' => 'storage/Blog/image/avatars/DRE07857 (1)_168897622923.jpg',
                        'gender' => 1,
            
                    ]);
                }
            }
        + Tạo nhiều dòng dữ liệu (khác nhau thì dùng Faker , không khác nhau thì cứ dùng như thế) . Dùng Factory : 
            + sử dụng "fakerphp/faker": "^1.9" (hoặc cái này cũng có sẵn trong laravel rồi)
                "require-dev": {
                    "fakerphp/faker": "^1.9"
                }
        
                => cài cái này thì ghi vào composer sau đó chạy lệnh : composer update

            UsersTableSeeder.php : 
            <?php
            namespace Database\Seeders;

            use Illuminate\Database\Seeder;
            use Illuminate\Support\Facades\DB;
            use Illuminate\Support\Facades\Hash;
            use Faker\Factory as Faker;

            class UsersTableSeeder extends Seeder
            {
                public function run()
                {
                    \App\Models\User::factory(3)->create();
                }
            }
            
            + bloglaravel\database\factories\UserFactory.php sẽ tương ứng với Model User 
                + UserFactory.php
                <?php
                    namespace Database\Factories;
        
                    use App\Models\User;
                    use Illuminate\Database\Eloquent\Factories\Factory;
                    use Illuminate\Support\Str;
                    use Illuminate\Support\Facades\Hash;
        
                    class UserFactory extends Factory
                    {
                        protected $model = User::class;
        
                        public function definition()
                        {
                            return [
                                'name' => $this->faker->name,
                                'email' => $this->faker->unique()->safeEmail,
                                'password' => Hash::make('password'),
                                'google_id' => $this->faker->randomNumber(9),
                                'github_id' => $this->faker->randomNumber(8),
                                'username' => $this->faker->userName,
                                'created_at' => now(),
                                'updated_at' => now(),
                                'email_verified_at' => now(),
                                'avatar' => 'storage/Blog/image/avatars/' . $this->faker->image('public/storage/Blog/image/avatars', 200, 200, null, false),
                                'gender' => $this->faker->numberBetween(0, 1),
                            ];
        
                        }
                    }
        + 'avatar' => 'storage/Blog/image/avatars/' . $this->faker->image('public/storage/Blog/image/avatars', 200, 200, null, false),
            => Tạo ảnh lưu vào folder sau đó lấy đường dẫn lưu vào database . 

    + Chạy Seeder:
        + Chạy 1 file :         
            > php artisan db:seed --class=UsersTableSeeder
        
        + Chạy nhiều file cùng lúc 
            > php artisan db:seed --class=Seeder1Seeder,Seeder2Seeder
        
    + Để tạo ra 10 mẫu dữ liệu khác biệt nhau thì ta làm như sau : 
        + Để sử dụng Faker để tạo ra 10 mẫu dữ liệu khác nhau cho bảng users, bạn cần thực hiện các bước sau:
        + Đảm bảo rằng bạn đã cài đặt gói Faker trong dự án Laravel của mình bằng cách thêm dòng sau vào tệp composer.json:


    + Ex : Article : 
        + php artisan make:seeder ArticlesTableSeeder
        + bloglaravel\database\seeders\ArticlesTableSeeder.php : 
            <?php
                namespace Database\Seeders;
        
                use Illuminate\Database\Seeder;
                use Illuminate\Support\Facades\DB;
                use Illuminate\Support\Facades\Hash;
                use Faker\Factory as Faker;
        
                class ArticlesTableSeeder extends Seeder
                {
                    /**
                    * Run the database seeds.
                    *
                    * @return void
                    */
                    public function run()
                    {
                        \App\Models\Article::factory(3)->create();
                    }
                }

        + Tạo file bloglaravel\database\factories\ArticleFactory.php : 
            <?php

                namespace Database\Factories;

                use App\Models\Article;
                use App\Models\User;
                use Illuminate\Database\Eloquent\Factories\Factory;
                use Illuminate\Support\Str;

                class ArticleFactory extends Factory
                {
                    /**
                    * The name of the factory's corresponding model.
                    *
                    * @var string
                    */
                    protected $model = Article::class;

                    /**
                    * Define the model's default state.
                    *
                    * @return array
                    */
                    public function definition()
                    {
                        $userIds = User::pluck('id')->toArray();

                        return [
                            'id_user' => $this->faker->randomElement($userIds),
                            'title' => $this->faker->sentence,
                            'content' => $this->faker->paragraph,
                            'created_at' => now(),
                            'updated_at' => now(),
                        ];
                    }
                }

        + php artisan db:seed --class=ArticlesTableSeeder

-----------------------------------------------Database relationship: one to one, one to many, ...---------------------------------------------------------------------
Trong Laravel, có nhiều loại quan hệ giữa các bảng trong cơ sở dữ liệu, bao gồm:

One-to-One Relationship (Quan hệ một một): Một bảng có một liên kết đến một bảng khác dựa trên một cặp khóa duy nhất.
One-to-Many Relationship (Quan hệ một nhiều): Một bảng có nhiều liên kết đến một bảng khác thông qua một cặp khóa.
Many-to-Many Relationship (Quan hệ nhiều nhiều): Nhiều bảng có thể có nhiều liên kết đến các bảng khác, thông qua một bảng trung gian.
Has-Many-Through Relationship (Quan hệ một nhiều qua): Một bảng có thể có nhiều liên kết đến một bảng khác thông qua một bảng trung gian.
Polymorphic Relationship (Quan hệ đa hình): Một bảng có thể có nhiều liên kết đến nhiều bảng khác, sử dụng một cột id và type.
Many-to-Many Polymorphic Relationship (Quan hệ nhiều nhiều đa hình): Kết hợp quan hệ nhiều nhiều và đa hình, cho phép nhiều bảng tham gia quan hệ.
Inverse Relationship (Quan hệ nghịch đảo): Quan hệ ngược của một quan hệ đã định nghĩa.

Ví dụ về một số quan hệ trong Laravel:

One-to-One Relationship:
class User extends Model {
    public function phone() {
        return $this->hasOne(Phone::class);
    }
}
class Phone extends Model {
    public function user() {
        return $this->belongsTo(User::class);
    }
}

One-to-Many Relationship:
class User extends Model {
    public function posts() {
        return $this->hasMany(Post::class);
    }
}
class Post extends Model {
    public function user() {
        return $this->belongsTo(User::class);
    }
}

Many-to-Many Relationship:
class User extends Model {
    public function roles() {
        return $this->belongsToMany(Role::class);
    }
}

class Role extends Model {
    public function users() {
        return $this->belongsToMany(User::class);
    }
}

Has-Many-Through Relationship:
class Country extends Model {
    public function posts() {
        return $this->hasManyThrough(Post::class, User::class);
    }
}

Polymorphic Relationship:
class Comment extends Model {
    public function commentable() {
        return $this->morphTo();
    }
}
class Post extends Model {
    public function comments() {
        return $this->morphMany(Comment::class, 'commentable');
    }
}
class Video extends Model {
    public function comments() {
        return $this->morphMany(Comment::class, 'commentable');
    }
}

Many-to-Many Polymorphic Relationship:
class Tag extends Model {
    public function posts() {
        return $this->morphedByMany(Post::class, 'taggable');
    }

    public function videos() {
        return $this->morphedByMany(Video::class, 'taggable');
    }
}

class Post extends Model {
    public function tags() {
        return $this->morphToMany(Tag::class, 'taggable');
    }
}

class Video extends Model {
    public function tags() {
        return $this->morphToMany(Tag::class, 'taggable');
    }
}
Đây chỉ là một số ví dụ về các quan hệ cơ bản trong Laravel. Mỗi loại quan hệ có cách sử dụng và định nghĩa riêng biệt, tùy thuộc vào cấu trúc dữ liệu của bạn.
        
------------------------------Validation Quickstart, Form Request, Custom Rule...------------------------------
Validation Quickstart: (kiến thức cũ)
    + Laravel cung cấp cách tiếp cận dễ dàng để thực hiện validation cho dữ liệu gửi từ form bằng cách sử dụng hàm validate() hoặc sử dụng lớp Validator.
    Sử dụng hàm validate() trong Controller:
    public function store(Request $request)
    {
        $validatedData = $request->validate([
            'name' => 'required|max:255',
            'email' => 'required|email|unique:users',
            'password' => 'required|confirmed|min:6',
        ]);

        // ... Xử lý dữ liệu
    }

    Sử dụng lớp Validator:
    use Illuminate\Support\Facades\Validator;

    $validator = Validator::make($request->all(), [
        'name' => 'required|max:255',
        'email' => 'required|email|unique:users',
        'password' => 'required|confirmed|min:6',
    ]);


    if ($validator->fails()) {
        return redirect('register')
                    ->withErrors($validator)
                    ->withInput();
        // => Ở đây có thể in lỗi ra 
    }

    <!-- Hoặc như dưới đây -->
    if ($validator->fails()) {
        foreach ($validator->errors()->all() as $error) {
            Toastr::error($error);
        }
    }
    // ... Xử lý dữ liệu

----------------------------------
Form Request:
    Form Request là một cách tốt để tách logic validation ra khỏi Controller và giữ cho Controller trở nên gọn gàng hơn. Để tạo một Form Request, bạn có thể sử dụng lệnh Artisan như sau:
    > php artisan make:request StoreUserRequest

    Sau đó, trong StoreUserRequest.php:
        public function authorize()
        {
            return true;
        }
        
        public function rules()
        {
            return [
                'name' => 'required|max:255',
                'email' => 'required|email|unique:users',
                'password' => 'required|confirmed|min:6',
            ];
        }

        public function withValidator($validator)
        {
            if ($validator->fails()) {
                foreach ($validator->errors()->all() as $error) {
                    Toastr::error($error);
                }
            }
        }

    Sau đó, trong Controller:
        public function store(StoreUserRequest $request)
        {
            // ...
        }

----------------------------------
Custom Rule: (Mới)
    + Nếu bạn muốn áp dụng validation logic phức tạp hơn, bạn có thể tạo Custom Rule.
    + Tạo Custom Rule:
        + php artisan make:rule Uppercase
        
        + Trong Uppercase.php:
            public function passes($attribute, $value)
            {
                return strtoupper($value) === $value;
            }

            public function message()
            {
                return 'The :attribute must be in uppercase.';
            }

        + Sử dụng Custom Rule:

            use App\Rules\Uppercase;
            $validatedData = $request->validate([
                'name' => ['required', new Uppercase],
            ]);

            Hoặc sử dụng trong Form Request:
            public function rules()
            {
                return [
                    'name' => ['required', new Uppercase],
                ];
            }
            Nhớ rằng, các Custom Rule cũng có thể nhận thêm các tham số để tùy chỉnh hành vi validation.
                + Ví dụ, bạn có thể tạo một Custom Rule để kiểm tra xem một số có lớn hơn một số khác đã được truyền vào hay không:
                    + Tạo Custom Rule:
                        + php artisan make:rule GreaterThanAnotherField
                        + Sau đó, trong GreaterThanAnotherField.php:
                            use Illuminate\Contracts\Validation\Rule;

                            class GreaterThanAnotherField implements Rule
                            {
                                protected $otherField;

                                public function __construct($otherField)
                                {
                                    $this->otherField = $otherField;
                                }

                                public function passes($attribute, $value)
                                {
                                    return $value > $this->otherField;
                                }

                                public function message()
                                {
                                    return "The :attribute must be greater than {$this->otherField}.";
                                }
                            }

                    + Sử dụng Custom Rule với tham số:
                        use App\Rules\GreaterThanAnotherField;

                        $otherFieldValue = 10; // Giá trị của trường khác
                        $validatedData = $request->validate([
                            'number' => ['required', new GreaterThanAnotherField($otherFieldValue)],
                        ]);

                    + Hoặc sử dụng trong Form Request:
                        public function rules()
                        {
                            $otherFieldValue = 10; // Giá trị của trường khác
                            return [
                                'number' => ['required', new GreaterThanAnotherField($otherFieldValue)],
                            ];
                        }

                => Như vậy, bạn có thể tùy chỉnh cách tham số được sử dụng trong Custom Rule để đáp ứng nhu cầu của từng tình huống validation.

----------------------------------

https://github.com/NguyenVanManh-AI/bap-bloglaravel

------------------------------Caching------------------------------
Caching     
    + Caching (lưu trữ tạm thời) là một kỹ thuật quan trọng trong phát triển phần mềm để cải thiện hiệu suất ứng dụng bằng cách lưu trữ dữ liệu tính toán hoặc truy vấn cơ sở dữ liệu trong bộ nhớ tạm thời. Khi dữ liệu được lưu trữ tại vị trí này, ứng dụng có thể truy cập nhanh chóng và tránh việc phải tính toán lại hoặc truy vấn cơ sở dữ liệu liên tục.
    + Laravel cung cấp nhiều cách để thực hiện caching trong ứng dụng của bạn.

    1. Caching Dữ liệu:
        Bạn có thể cache dữ liệu kết quả từ các truy vấn cơ sở dữ liệu hoặc từ bất kỳ nguồn dữ liệu nào khác. Laravel hỗ trợ cache bằng cách sử dụng Cache facade hoặc thông qua Dependency Injection.

        // Sử dụng Cache facade
        $value = Cache::get('key');
        Cache::put('key', $value, $minutes);

        // Sử dụng Dependency Injection
        use Illuminate\Contracts\Cache\Repository as Cache;

        public function __construct(Cache $cache)
        {
            $this->cache = $cache;
        }

        $value = $this->cache->get('key');
        $this->cache->put('key', $value, $minutes);

    2. Caching View:
        Laravel cho phép bạn cache kết quả của view để tăng hiệu suất render view. Sử dụng lệnh Artisan để tạo view cache.
        php artisan view:cache

    3. Cache Route:
        Laravel cung cấp tích hợp cho việc cache route. Bạn có thể cache route để giảm thời gian xử lý route.
        Route::get('profile', function () {
            //
        })->middleware('cacheResponse:600'); // Cache for 10 minutes

    4. Cache Fragment:
        Caching fragment cho phép bạn cache một phần của view, chứ không phải toàn bộ view.
        @cache('key')
            <div>
                <!-- Content to be cached -->
            </div>
        @endcache

    5. Caching Query:
        Laravel cho phép bạn cache kết quả của các truy vấn cơ sở dữ liệu.
        $users = DB::table('users')->remember(10)->get(); // Cache for 10 minutes

    6. Caching Configuration:
        Bạn có thể cache configuration để tránh phải đọc file cấu hình mỗi lần ứng dụng khởi động.
        php artisan config:cache
        Tất cả các loại cache đều có thể được quản lý và xóa thông qua các lệnh Artisan hoặc thông qua tùy chọn cấu hình. Caching là một cách mạnh mẽ để cải thiện hiệu suất ứng dụng và giảm tải cho cơ sở dữ liệu.


Ví dụ dễ hiểu về Caching : 
    + Ví dụ để lấy dữ liệu của toàn bộ sản phẩm , ta cũng sẽ code vào controller như bình thường, nhưng có thể sử dụng thêm Caching với 
    với mục đích là : Lưu dữ liệu lấy được , ví dụ lưu toàn bộ sản phẩm lấy được vào cache và thiết lập trong khoảng thời gian bao nhiêu đó . 
    Nếu trong khoản thời gian này mà hệ thống gọi lại hàm getProducts() thì nó không cần query lại nữa mà lấy dữ liệu đã lưu từ trước 
    đó trong cache . Hết thời gian quy định thì xóa cache đi và nếu như gọi getProducts() và nó kiểm tra trong cache không 
    có biến lưu toàn bộ sản phẩm thì nó lại bắt đầu một query mới và thiết lập lại thời gian mới . (Cứ như thế lặp đi lặp lại)
    Ví dụ : $products = Cache::remember('products', 60, function () { => thiết lập 60 phút 

    + Lưu ý : 
        + Việc lấy cache này có thể gặp vấn đề khi mà cache vẫn lưu giá trị cũ , trong khi trong database đã update cái mới 
        + Ví dụ : Lấy toàn bộ sản phẩm lưu trong 60 phút . Trong 60 phút đó , giả sử có người update các sản phẩm rồi 
        thì khi ta lấy ra mà vẫn lấy trong cache thì vẫn đang lấy cái cũ . 
            => hướng giải quyết là khi update nói chung hay bất cứ hành động liên quan đến tất cả sản phẩm 
            làm cho tất cả sản phẩm trong database thay đổi thì cần phải xóa biến cache lưu tất cả các sản phẩm đi 
            và update lại biến cache mới lưu tất cả các sản phẩm có chứa các sản phẩm vừa mới update . 

    1. Cache dữ liệu danh sách sản phẩm:
        + Trong Controller của bạn, bạn có thể sử dụng Cache facade để lưu trữ danh sách sản phẩm từ cơ sở dữ liệu:
        use Illuminate\Support\Facades\Cache;
        use App\Models\Product;

        public function getProducts()
        {
            $products = Cache::remember('products', 60, function () {
                return Product::all();
            });

            return view('products.index', ['products' => $products]);
        }

    => Trong đoạn mã trên, danh sách sản phẩm sẽ được lưu trữ trong cache trong vòng 60 phút. Nếu bạn gọi hàm getProducts() trong khoảng thời gian 60 phút, dữ liệu sẽ được lấy từ cache mà không cần truy vấn lại cơ sở dữ liệu.
    2. Xóa Cache khi dữ liệu thay đổi:
        + Khi bạn thêm, sửa hoặc xóa sản phẩm, bạn nên xóa cache để đảm bảo rằng dữ liệu mới nhất sẽ được hiển thị. Bạn có thể sử dụng hàm forget để xóa cache:
        + Cache::forget('products');
        => Đặt hàm này trong các hành động tạo, sửa hoặc xóa sản phẩm.

    3. Sử dụng tên cache phân cấp:
        + Nếu bạn muốn xử lý cache phân cấp theo từng danh mục hoặc trang, bạn có thể sử dụng tên cache phân cấp:
            $category = 'electronics'; // thiết bị điện tử 
            $cacheKey = "products.$category";

            $products = Cache::remember($cacheKey, 60, function () use ($category) {
                return Product::where('category', $category)->get();
            });

        => Trong ví dụ này, dữ liệu danh sách sản phẩm của danh mục "electronics" sẽ được lưu trữ riêng biệt với tên cache phân cấp "products.electronics".
        => Caching là một công cụ mạnh mẽ để cải thiện hiệu suất ứng dụng và giảm tải cho cơ sở dữ liệu. 
        Tuy nhiên, hãy cẩn thận khi sử dụng caching để đảm bảo rằng dữ liệu luôn được cập nhật đúng và không gây ra sự cố không mong muốn.

------------------------------Schedule Job và Queue------------------------------

Schedule job (lên lịch công việc) và queue (hàng đợi)

=> Schedule Job và Queue là hai khái niệm quan trọng trong Laravel liên quan đến quản lý các tác vụ chạy dưới nền hoặc theo lịch trình. 
Dưới đây là sự khác nhau giữa chúng:

+ Schedule Job:
Schedule Job trong Laravel được sử dụng để thực hiện các tác vụ định kỳ theo lịch trình đã xác định.
Để định nghĩa và cấu hình Schedule Job, bạn sử dụng class Kernel (thường là file app/Console/Kernel.php) để xác định các tác vụ cần chạy định kỳ. Bạn có thể sử dụng các phương thức như daily(), hourly(), everyMinute(),... để lên lịch thực hiện các tác vụ.
Schedule Job thường được sử dụng cho các tác vụ cần thực hiện định kỳ theo lịch như gửi email hàng ngày, làm sạch dữ liệu, cập nhật thông tin và nhiều tác vụ khác.

+ Queue:
Queue trong Laravel là hệ thống cho phép bạn xử lý các tác vụ nền mà không cần chờ đợi chúng hoàn thành trước khi tiếp tục xử lý.
Các tác vụ trong Queue được xử lý bởi các workers, tức là các tiến trình chạy độc lập với ứng dụng chính. Điều này giúp tách biệt quá trình xử lý tác vụ nền và tạo ra trải nghiệm ứng dụng tốt hơn cho người dùng.
Queue thường được sử dụng cho các tác vụ mất nhiều thời gian xử lý như gửi email hàng loạt, xử lý tác vụ tải nặng, tính toán phức tạp, v.v.
Tóm lại, Schedule Job dùng để thực hiện các tác vụ định kỳ theo lịch, trong khi Queue dùng để xử lý các tác vụ nền một cách bất đồng bộ và không ảnh hưởng đến việc xử lý của ứng dụng chính.

------------------------------Schedule Job và Queue------------------------------

+ Schedule Job : Lên lịch công việc (hàng ngày, giây, phút, giờ, tuần,...)
+ Queue : Hàng đợi (không phải là bất đồng bộ như bên JS mà bên PHP sẽ là thực hiện đồng bộ từ trên xuống
    => chính vì thế tác vụ nào lâu nên cho vào hàng đợi)

+ Ví dụ sử dụng Schedule Job để gửi mail hàng ngày : 

    + Cách 1 : Dùng Jobs : 
        + Để thực hiện việc gửi email hàng ngày cho tất cả các địa chỉ email trong bảng "users", bạn có thể sử dụng Laravel's Schedule và Mail. 
        Dưới đây là ví dụ cụ thể về cách làm điều này:

        + Tạo một Job để Gửi Email:
            + Đầu tiên, bạn cần tạo một job để thực hiện việc gửi email. Hãy tạo một job bằng câu lệnh sau:
            + php artisan make:job SendDailyEmail

            + Sau đó, mở file app/Jobs/SendDailyEmail.php và định nghĩa logic gửi email trong hàm handle():
                use App\Models\User;
                use Illuminate\Bus\Queueable;
                use Illuminate\Contracts\Queue\ShouldQueue;
                use Illuminate\Foundation\Bus\Dispatchable;
                use Illuminate\Queue\InteractsWithQueue;
                use Illuminate\Queue\SerializesModels;
                use Illuminate\Support\Facades\Mail;
                use App\Mail\DailyEmail;

                class SendDailyEmail implements ShouldQueue
                {
                    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

                    public function handle()
                    {
                        $users = User::all();

                        foreach ($users as $user) {
                            Mail::to($user->email)->send(new DailyEmail($user));
                        }
                    }
                }

            + Tạo Mailable:
                + Bạn cần tạo một Mailable để định dạng nội dung email. Hãy tạo một Mailable bằng câu lệnh sau:
                + php artisan make:mail DailyEmail
                + Sau đó, trong file app/Mail/DailyEmail.php, bạn có thể định nghĩa nội dung email:
                    use App\Models\User;
                    use Illuminate\Bus\Queueable;
                    use Illuminate\Contracts\Queue\ShouldQueue;
                    use Illuminate\Mail\Mailable;
                    use Illuminate\Queue\SerializesModels;

                    class DailyEmail extends Mailable
                    {
                        use Queueable, SerializesModels;

                        public $user;

                        public function __construct(User $user)
                        {
                            $this->user = $user;
                        }

                        public function build()
                        {
                            return $this->markdown('emails.daily', ['user' => $this->user]);
                        }
                    }

            + Định lịch gửi email hàng ngày:
                + Mở file app/Console/Kernel.php và thêm đoạn code trong phương thức schedule():
                    use App\Jobs\SendDailyEmail;

                    protected function schedule(Schedule $schedule)
                    {
                        $schedule->job(new SendDailyEmail)->daily();
                    }
            + Tạo View cho Email:
                + Trong thư mục resources/views/emails, tạo một file daily.blade.php để định dạng email.
            
            + Cuối cùng, chạy các lệnh sau:
                php artisan queue:work   (mỗi lệnh chạy một terminal)
                php artisan schedule:run (mỗi lệnh chạy một terminal)

            + Laravel sẽ tự động gửi email hàng ngày cho tất cả các địa chỉ email trong bảng "users".

        
        + Thiết lập ngày và giờ khác : 
            + Mở file app/Console/Kernel.php và thay thế phương thức daily() bằng dailyAt('08:00'):
                use App\Jobs\SendDailyEmail;

                protected function schedule(Schedule $schedule)
                {
                    $schedule->job(new SendDailyEmail)->dailyAt('08:00');
                }

        
            + Mỗi phút : $schedule->job(new SendDailyEmail)->everyMinute();
            + Mỗi giây : $schedule->job(new SendDailyEmail)->everySecond();
            + Mỗi giờ  : $schedule->job(new SendDailyEmail)->hourly();
            + Mỗi tuần (vào thứ 2 lúc 8h) : $schedule->job(new SendDailyEmail)->weeklyOn(1, '8:00');
            + Mỗi tháng (ngày 1 lúc 8h) : $schedule->job(new SendDailyEmail)->monthlyOn(1, '8:00');
            + Mỗi năm (ngày 1 tháng 1 lúc 8h) : $schedule->job(new SendDailyEmail)->yearlyOn(1, 1, '8:00');

        + Nhớ rằng, để kích hoạt các lịch trình này, bạn cần chạy lệnh php artisan schedule:run.

        + Tham khảo thêm về Schedule Command : https://therealprogrammer.com/laravel-8-cron-job-task-scheduling-tutorial/ 
        + Nhập lệnh : php artisan => có thể xem toàn bộ thông tin của project trong đó có cả những schedule và queue 

    + Cách 2 : Dùng Command : 
        + php artisan make:command SendMail
        + bloglaravel\app\Console\Commands\SendMail.php : 
            <?php

                namespace App\Console\Commands;

                use App\Models\User;
                use Illuminate\Console\Command;
                use Illuminate\Support\Facades\Mail;
                use App\Mail\DailyEmail;

                class SendMail extends Command
                {
                    // protected $signature = 'command:name';   
                    protected $signature = 'users:sendmail';    <= Đây là lệnh command 

                    protected $description = 'Send mail to all users by running this command';

                    public function __construct()
                    {
                        parent::__construct();
                    }

                    public function handle()
                    {
                        $users = User::all();
                        foreach ($users as $user) {
                            Mail::to($user->email)->send(new DailyEmail($user));
                        }
                        // return 0;
                    }
                }

        + Sau đó ta nhập : php artisan => sẽ thấy lệnh 'users:sendmail' cùng dòng mô tả 'Send mail to all users by running this command'
        + bloglaravel\app\Console\Kernel.php
            <?php

            namespace App\Console;
            
            use Illuminate\Console\Scheduling\Schedule;
            use Illuminate\Foundation\Console\Kernel as ConsoleKernel;
            use App\Jobs\SendDailyEmail;
            
            class Kernel extends ConsoleKernel
            {
                protected $commands = [
                    Commands\SendMail::class,
                ];
            
                protected function schedule(Schedule $schedule)
                {
                    $schedule->command('users:sendmail')->everyMinute(); // thực hiện lệnh command 
                    // $schedule->command('users:sendmail')->cron('* * * * *'); // thực hiện lệnh command 
                    // $schedule->command('users:sendmail')->hourly(); // thực hiện lệnh command 
                    // $schedule->command('minute:update')->hourly();
                    // $schedule->job(new SendDailyEmail)->daily();
                    // $schedule->job(new SendDailyEmail)->everyMinute(); // Mỗi phút  
                    // $schedule->job(new SendDailyEmail)->everySecond(); // Mỗi giây 
                    // $schedule->job(new SendDailyEmail)->hourly(); // Mỗi giờ 
                    // $schedule->job(new SendDailyEmail)->weeklyOn(1, '8:00'); // Mỗi tuần (vào thứ 2 lúc 8h) 
                    // $schedule->job(new SendDailyEmail)->monthlyOn(1, '8:00'); // Mỗi tháng (ngày 1 lúc 8h) 
                    // $schedule->job(new SendDailyEmail)->yearlyOn(1, 1, '8:00'); // Mỗi năm (ngày 1 tháng 1 lúc 8h) 
                }
            
                protected function commands()
                {
                    $this->load(__DIR__.'/Commands');
            
                    require base_path('routes/console.php');
                }
            }
        
        + Chạy lệnh : php artisan users:sendmail để thử nghiệm xem chạy ok chưa 
        + Chạy lệnh : php artisan schedule:run

+ Ví dụ sử dụng Queue để cho vào hàng đợi, lấy ví dụ thực tế trong việc gửi mail cho nhiều người : 
    + Để thực hiện việc gửi email đến tất cả các địa chỉ email trong bảng người dùng (table users) bằng cách sử dụng Queue, 
    bạn có thể sử dụng một thư viện hỗ trợ hàng đợi như Laravel Queue. Dưới đây là một ví dụ về cách bạn có thể viết mã trong Laravel:
    + Trước hết, hãy tạo một job để xử lý việc gửi email. Trong thư mục app/Jobs, bạn có thể tạo một tệp tin mới với tên là SendEmailJob.php:
    + php artisan make:job SendEmailJob
    + Sau đó, trong tệp tin app/Jobs/SendEmailJob.php, bạn có thể thêm logic để gửi email:
        namespace App\Jobs;

        use Illuminate\Bus\Queueable;
        use Illuminate\Contracts\Queue\ShouldQueue;
        use Illuminate\Foundation\Bus\Dispatchable;
        use Illuminate\Queue\InteractsWithQueue;
        use Illuminate\Queue\SerializesModels;
        use Illuminate\Support\Facades\Mail;
        use App\Mail\YourMail; // Thay YourMail bằng mẫu thư bạn muốn gửi

        class SendEmailJob implements ShouldQueue
        {
            use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

            protected $email;

            public function __construct($email)
            {
                $this->email = $email;
            }

            public function handle()
            {
                Mail::to($this->email)->send(new YourMail()); // Thay YourMail bằng mẫu thư bạn muốn gửi
            }
        }
    
    + Tiếp theo, trong hàm sendAll() của ControllerUser, bạn có thể lặp qua tất cả các địa chỉ email trong bảng người dùng và đưa chúng vào hàng đợi gửi email:
        use App\Jobs\SendEmailJob;
        use App\Models\User;

        class ControllerUser extends Controller
        {
            public function sendAll()
            {
                $users = User::all();

                foreach ($users as $user) {
                    dispatch(new SendEmailJob($user->email));
                }

                return "Emails are being sent in the background.";
            }
        }

    + Cuối cùng, đảm bảo rằng bạn đã cấu hình hàng đợi trong tệp .env của bạn và chạy tác vụ hàng đợi bằng cách chạy lệnh sau:
    + php artisan queue:work
    => Như vậy, mỗi địa chỉ email sẽ được đưa vào hàng đợi gửi email và được xử lý một cách song song trong hàng đợi.


    
+ Để cấu hình hàng đợi trong Laravel, bạn cần chỉnh sửa tệp .env của dự án của mình. Dưới đây là một số cài đặt liên quan đến hàng đợi mà bạn cần thay đổi trong tệp .env:
    + Cấu hình driver hàng đợi: Bạn cần xác định driver hàng đợi bạn muốn sử dụng. Laravel hỗ trợ nhiều driver như sync (đồng bộ), database, redis, beanstalkd, sqs (Amazon Simple Queue Service) và nhiều cái khác. Ví dụ, để sử dụng driver database, bạn có thể thêm dòng sau vào tệp .env:

        QUEUE_CONNECTION=database
        Kết nối cho driver hàng đợi: Nếu bạn chọn sử dụng driver database, bạn cần chỉ định kết nối cơ sở dữ liệu mà bạn muốn sử dụng cho hàng đợi. Ví dụ:
        DB_CONNECTION=mysql
        DB_QUEUE_TABLE=jobs
        Cấu hình Redis (nếu sử dụng Redis): Nếu bạn chọn sử dụng driver redis, bạn cần cung cấp thông tin kết nối đến máy chủ Redis:
        
        REDIS_HOST=127.0.0.1
        REDIS_PASSWORD=null
        REDIS_PORT=6379
        Chạy tác vụ hàng đợi: Cuối cùng, bạn cần chạy tác vụ hàng đợi để xử lý các công việc trong hàng đợi. Sử dụng lệnh sau:
        
        php artisan queue:work
        Ví dụ, nếu bạn đã cấu hình driver là database, bạn sẽ thấy các công việc hàng đợi được lưu trong bảng jobs của cơ sở dữ liệu và tác vụ hàng đợi (php artisan queue:work) sẽ lấy các công việc này và xử lý chúng một cách song song.
        
        Lưu ý rằng cấu hình hàng đợi có thể thay đổi tùy theo yêu cầu và môi trường của dự án của bạn. Hãy xem tài liệu chính thức của Laravel để biết thêm thông tin về cấu hình hàng đợi: https://laravel.com/docs/8.x/queues

------------------------------Relationships------------------------------






